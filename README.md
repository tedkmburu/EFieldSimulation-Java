# Electric Field Simulation

**Team Members:** Chandana Sunkara, Ted Mburu  
**Java Version:** 23.0.1 (JDK 23)  

---

## Table of Contents

1. [Project Overview](#project-overview)  
2. [Features](#features)  
3. [Technical Architecture](#technical-architecture)  
4. [Prerequisites](#prerequisites)  
5. [Installation & Setup](#installation--setup)  
6. [Running the Simulation](#running-the-simulation)  
7. [Controls & Interaction](#controls--interaction)  
8. [Directory Structure](#directory-structure)  
9. [Testing](#testing)  
10. [Contributing](#contributing)  
11. [License](#license)
12. [Acknowledgements & References](#acknowledgements--references)
13. [Contact](#contact)  

---

## Project Overview

This interactive Java application visualizes electric fields generated by configurable point charges. Built using the [Processing](https://processing.org/) framework for rendering and [ControlP5](http://www.sojamo.de/libraries/controlP5/) for UI components, it demonstrates:

- **Field lines** tracing the path of field vectors  
- **Force vectors** at grid points and cursor position  
- **Equipotential lines** based on voltage contours  
- **Voltage gradient** shading across the canvas  

Users can add, drag, and customize charges in real time, as well as explore several preset charge configurations (single, dipole, row, dipole-row, random).

---

## Features

- ✔️ **Dynamic Point Charges**: Place positive, negative, or neutral charges interactively  
- ✔️ **Visualization Modes**  
  - Field Lines  
  - Field Vectors (grid & mouse)  
  - Equipotential Lines  
  - Voltage Gradient  
- ✔️ **Preset Configurations**: Single, Dipole, Row, Dipole-Row, Random  
- ✔️ **Test Charge Mapping**: Simulate a “test charge” exploring the field  
- ✔️ **Grid & Snap-to-Grid** for precise placement  
- ✔️ **Undo/Redo** via Command Pattern  
- ✔️ **Side-Panel UI**: Toggle modes, change parameters, clear/reset  
- ✔️ **JUnit Test Suite**: Ensures core model and interaction logic  

---

## Technical Architecture

- **Core Simulation** (`org.example.model.SimulationModel`)  
- **Modes** (`org.example.engine.modes`): Strategy-style classes handling update/display for each visualization  
- **UI Layer** (`org.example.view.ui.ControlPanel`): ControlP5 interface  
- **Input Handling** (`org.example.controller.InputController`)  
- **Factory Pattern** for creating charges & field elements  
- **Command Pattern** (`org.example.controller.commands`) for undoable interactions  
- **Config Manager** (`org.example.model.config.ConfigManager`) centralizes constants  

---

## Prerequisites

- **Java Development Kit** (JDK) 23.0.1 or later  
- **Maven** or **Gradle** (if you integrate build scripts)  
- **Processing** core library (≥ 4.0)  
- **ControlP5** library (≥ 2.2.6)  
- **JUnit** 5 for tests  

---

## Installation & Setup

1. **Clone the repository**  
   ```bash
   git clone https://github.com/tedkmburu/EFieldSimulation-Java.git
   cd EFieldSimulation-Java
   ```

2. **Add Dependencies**
    - Copy `processing-core.jar` and `controlP5.jar` into a `/libs` folder
    - Ensure your IDE (IntelliJ/Eclipse) includes `/libs` on the classpath

3. **Build**
    - **IDE**: Import as a Java project, then _Build_
    - **Command-line** (if using Maven/Gradle):
      ```bash
      mvn clean compile
      # or
      gradle build
      ```

---

## Running the Simulation

```bash
# From your IDE:
Run the `org.example.Main` class

# Or, from the command line (after compilation):
java -cp "libs/*:target/classes" org.example.Main
```

Upon launch, the window will display the electric field canvas alongside a side-panel UI. Preset dipole configuration loads by default.

---

## Controls & Interaction

- **Left-click** on canvas:
    - Default: Add a new point charge
    - *Equipotential Mode:* Draw an equipotential line
    - *Test-Charge Mode:* Place a test charge

- **Drag** an existing point charge to reposition
- **Arrow keys** (when a charge is selected): Increase/decrease magnitude
- **Delete/Backspace**: Remove selected charge
- **UI Toggles**: Enable/disable each visualization mode and grid snapping

---

## Directory Structure

```
├── src
│   ├── main
│   │   ├── java
│   │   │   ├── org.example
│   │   │   │   ├── Main.java
│   │   │   │   ├── controller
│   │   │   │   │   └── InputController.java
│   │   │   │   ├── model
│   │   │   │   │   ├── SimulationModel.java
│   │   │   │   │   ├── config
│   │   │   │   │   └── ...  
│   │   │   │   ├── view
│   │   │   │   │   └── ui
│   │   │   │   └── engine
│   │   │   │       └── modes
│   │   │   └── controller/commands
│   │   └── resources
│   └── test
│       └── java
│           └── org.example   (JUnit tests)
└── libs       (Processing, ControlP5 jars)
```

---

## Testing

Run the complete JUnit suite to verify:

```bash
# IDE: Run all tests under src/test/java  
# Maven:
mvn test
# Gradle:
gradle test
```

---

## Contributing

1. Fork & clone
2. Create a feature branch: `git checkout -b feature/YourFeature`
3. Commit your changes: `git commit -m "Add YourFeature"`
4. Push & open a Pull Request
5. Ensure tests pass and style is consistent

Please follow existing code conventions and write unit tests for new features.

---

## License

This project is released under the **MIT License**. See [LICENSE](LICENSE) for details.

---

## Acknowledgements & References

- **Processing.org** – Core graphics framework
- **ControlP5** – GUI controls for Processing
- [Original JavaScript Simulation](https://icphysweb.z13.web.core.windows.net/simulation.html)

